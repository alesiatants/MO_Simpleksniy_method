// Симплексный метод.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <clocale>
#include <conio.h>
#include <cmath>
#include <cstring>
#define pow2(x) (x)*(x)
using namespace std;
int n;
double **s;

//целевая функция
double f(double *x) {
    
        return pow2(x[0]) + 2 * pow2(x[1]) - 3 * x[0] + 5 * x[1] + 1;
}

int num_top_max_min(const char* q) {
    int i, j = 0;
    double res;
    //определение значения целевой функции в первой вершине, заданной пользователем
    res = s[0][n];
    for (i = 1; i <= n; i++) {
        //определение типа необходимого сравнения значений целевой функции в точке (максимум или минимум)
        //ексикографическую проверку двух строк: параметра q и значения max 
        switch (strcmp(q, "max"))
        {
            //если совпадает
        case 0: 
            //если следующая вершина больше начальной
            if (s[i][n] > res) {
                //переустанавливаем данную вершину в качестве максимальной
                res = s[i][n];
                //запоминаем номер максимальной вершины в массиве s
                j = i;
            }
            break;
            //если q больше max
        case 1:
            //если следующая вершина меньше начальной
            if (s[i][n] < res) {
                //переустанавливаем данную вершину в качестве минимальной
                res = s[i][n];
                //запоминаем номер минимальной вершины в массиве s
                j = i;
            }
            break;
        default:
            break;
        }
        
    }
    return j;
}

void Func_in_top(double* x) {
    int i, j;
    for (i = 0; i <= n; i++) {
        for (j = 0; j < n; j++) {
            x[j] = s[i][j];
        }
        //запоминаем 3 членом массива s значение функции в данной точке помимо  2 координат этой точки
        s[i][n] = f(x);
    }
}
int main()
{
    setlocale(LC_ALL, "Russian");
    double fotrag, koord1, koord2, m, eps;
    int i, j, num_top, k=0;
    cout << "Расчет оптимального решения задачи\n";
    cout << "Введите размерность задачи оптимизации n="; cin >> n;
    double* x = new double[n];
    double* xc = new double[n];
    s = new double* [n + 1];
    for (i = 0; i <= n; i++) {
        s[i] = new double[n + 1];
    }
    cout << "Введите точность вычисления eps ="; cin >> eps;
    cout << "Введите начальную длину ребра симплекса m = "; cin >> m;
    cout << "Введите кординаты начальной точки \n";
    //Задание начальной точки симплекса
    for (j = 0; j < n; j++) {
        cout << "x[" << j + 1 << "] ="; cin >> s[0][j];
    }
    
    //вычисление приращения
    koord1 = ((sqrt(n + 1) - 1) / (n * sqrt(2))) * m;
    koord2 = ((sqrt(n + 1) + n- 1) / (n * sqrt(2))) * m;
    //расчет координат остальных вершин симплекса
    for (i = 1; i <= n; i++) {
        for (j = 0; j < n; j++) {
            if (i == j + 1) {
                
                s[i][j] = s[0][j] + koord1;

            }
            else s[i][j] = s[0][j] + koord2;
        }
    }
    // вычисление целевой функции в полученных 3 вершинах (1-задано пользователем, 2 и 3 вычислены в предыдущем цикле)
    Func_in_top(x);

    do {
        //определение номера вершины с максимальным значением функции
        num_top = num_top_max_min("max");
        //находим точку центра тяжести
        for (j = 0; j < n; j++) {
            fotrag = 0;
            for (i = 0; i <= n; i++) {
                //условие на принятия во внимание всех точек кроме той, что с максимальным значением функции
                //суммируем значение первых/вторых координат двух точек
                if (i != num_top) fotrag += s[i][j];

            }
            //запоминаем в резервный массив xc  сумму координат, деленную на размерность задачи
            xc[j] = fotrag / n;
        }
        //нахождение координаты отраженной вершины, используя свойство регулярности
        for (j = 0; j < n; j++) {
            x[j] = 2 * xc[j] - s[num_top][j];
        }
        //опредиление значения функции в отраженной точке
        fotrag = f(x);
        //поверка на удачность операции отражения
        if (fotrag < s[num_top][n]) {
            //в качестве новой точки берем координаты отраженной точки
            for (j = 0; j < n; j++)s[num_top][j] = x[j];
            //в качестве значения целевой функции в новой точке берем ее значение в отраженной точке
            s[num_top][n] = fotrag;
        }
        //процесс редукции. Определяется номер вершины с минимальным значением функции
        else {
            //определение номера вершины с минимальным значением функции
            num_top = num_top_max_min("min");
            for (j = 0; j < n; j++) {
                for (i = 0; i <= n; i++) {
                    //условие на принятия во внимание всех точек кроме той, что с минимальным значением функции
                //формируем новый многогранник с уменьшенными вдвое сторонами
                    if (i != num_top)s[i][j] = 0.5 * (s[num_top][j] + s[i][j]);
                }
            }
            // вычисление целевой функции в полученных 3 вершинах 
            Func_in_top(x);
        }

        //определение центра тяжести симплекса
        for (j = 0; j < n; j++) {
            fotrag = 0;
            //расчитываем сумму координат в трех точках
            for (i = 0; i <= n; i++) fotrag += s[i][j];
            //записываем в резервный массив значение суммы координат деленной на размерность задачи увеличинной на 1
                xc[j] = fotrag / (n + 1);
        }   

        //расчитываем значение целевой функции в полученной точке - центре тяжести
        fotrag = f(xc);
        num_top = 0;

        for (i = 0; i <= n; i++) {
            //проверка условия окончания поска
            if (fabs(fotrag - s[i][n]) < eps) num_top++;
        }
        k++;
    } while (num_top != n + 1); //условие окочания итерации

    //определение номера вершины с наименьшим значением целевой функции
    num_top = num_top_max_min("min");

    cout << "\nРезультаты оптимизации: \n";
    for (j = 0; j < n; j++)
        cout << "\nx[" << j + 1 << "] = " << s[num_top][j];
    cout << "\nЗначение целевой функции f* = " << s[num_top][n] << "\n";
    cout << "\nЧисло итераций k = " << k << endl;


    delete[]x;
    delete[]xc;
    delete[]s[0];
    delete[]s;

}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
